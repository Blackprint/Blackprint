{"version":3,"sources":["Blackprint.js","Node.js","Function.js","Input.js","Trigger.js","Cable.js","Port.js","utils.js","container/cables.js","container/container.js","container/drop-down.js","container/dropdown.js","container/nodes.js","nodes/default.js","end.js"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA","file":"blackprint.min.js","sourcesContent":["// Start private scope for Blackprint Module\r\n;(function(global, factory){\r\n  if(typeof exports === 'object' && typeof module !== 'undefined')\r\n  \treturn module.exports = factory(global);\r\n  factory(global);\r\n}(typeof window !== \"undefined\" ? window : this, (function(window){\r\n\r\nif(window.Blackprint === void 0)\r\n\twindow.Blackprint = {\r\n\t\tsettings:function(which, val){\r\n\t\t\tBlackprint.settings[which] = val;\r\n\t\t}\r\n\t};\r\n\r\nvar Blackprint = window.Blackprint;\r\n\r\nBlackprint.Sketch = class Sketch{\r\n\t// Create new blackprint container\r\n\tconstructor(){\r\n\t\tthis.index = Blackprint.index++;\r\n\t\tthis.scope = Blackprint.space.getScope(this.index);\r\n\t}\r\n\r\n\tsettings(which, val){\r\n\t\tBlackprint.settings[which] = val;\r\n\t}\r\n\r\n\t// Clone current container index\r\n\tcloneContainer(index){\r\n\t\treturn Blackprint.space.getHTML(index || Blackprint.index);\r\n\t}\r\n\r\n\t// Register node handler\r\n\t// Callback function will get handle and node\r\n\t// - handle = Blackprint binding\r\n\t// - node = ScarletsFrame binding <~> element\r\n\tregisterNode(namespace, func){\r\n\t\tdeepProperty(Blackprint.nodes, namespace.split('/'), func);\r\n\t}\r\n\r\n\t// Register new node type\r\n\tregisterInterface(nodeType, options, func){\r\n\t\tif(/[^\\w\\-]/.test(nodeType) !== false)\r\n\t\t\treturn console.error(\"nodeType can only contain character a-zA-Z0-9 and dashes\");\r\n\r\n\t\tif(options.extend === void 0 || options.template === void 0)\r\n\t\t\tthrow new Error(\"Please define the node template and the extend options\");\r\n\r\n\t\tif(!(options.extend.prototype instanceof Blackprint.Node))\r\n\t\t\tthrow new Error(options.extend.constructor.name+\" must be instance of Blackprint.Node\");\r\n\r\n\t\t// Just like how we do it on ScarletsFrame component with namespace feature\r\n\t\tBlackprint.space.component(nodeType+'-node', options, func);\r\n\t}\r\n\r\n\t// Import node positions and cable connection from JSON\r\n\timportJSON(json){\r\n\t\tif(json.constructor === String)\r\n\t\t\tjson = JSON.parse(json);\r\n\r\n\t\tvar version = json.version;\r\n\t\tdelete json.version;\r\n\r\n\t\tvar inserted = [];\r\n\t\tvar handlers = [];\r\n\r\n\t\t// Prepare all nodes depend on the namespace\r\n\t\t// before we create cables for them\r\n\t\tfor(var namespace in json){\r\n\t\t\tvar nodes = json[namespace];\r\n\r\n\t\t\t// Every nodes that using this namespace name\r\n\t\t\tfor (var a = 0; a < nodes.length; a++){\r\n\t\t\t\tvar nodeOpt = {\r\n\t\t\t\t\tx:nodes[a].x,\r\n\t\t\t\t\ty:nodes[a].y\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif(nodes[a].options !== void 0)\r\n\t\t\t\t\tnodeOpt.options = nodes[a].options;\r\n\r\n\t\t\t\tinserted[nodes[a].id] = this.createNode(namespace, nodeOpt, handlers);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Create cable only from outputs and properties\r\n\t\t// > Important to be separated from above, so the cable can reference to loaded nodes\r\n\t\tfor(var namespace in json){\r\n\t\t\tvar nodes = json[namespace];\r\n\r\n\t\t\t// Every nodes that using this namespace name\r\n\t\t\tfor (var a = 0; a < nodes.length; a++){\r\n\t\t\t\tvar node = inserted[nodes[a].id];\r\n\r\n\t\t\t\t// If have outputs connection\r\n\t\t\t\tif(nodes[a].outputs !== void 0){\r\n\t\t\t\t\tvar out = nodes[a].outputs;\r\n\r\n\t\t\t\t\t// Every outputs port that have connection\r\n\t\t\t\t\tfor(var portName in out){\r\n\t\t\t\t\t\tvar linkPortA = node.outputs[portName];\r\n\t\t\t\t\t\tif(linkPortA === void 0){\r\n\t\t\t\t\t\t\tconsole.error(\"Node port not found for\", node, \"with name:\", portName);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar port = out[portName];\r\n\r\n\t\t\t\t\t\t// Current outputs's available targets\r\n\t\t\t\t\t\tfor (var k = 0; k < port.length; k++) {\r\n\t\t\t\t\t\t\tvar target = port[k];\r\n\t\t\t\t\t\t\tvar targetNode = inserted[target.id];\r\n\r\n\t\t\t\t\t\t\t// Outputs can only meet input port\r\n\t\t\t\t\t\t\tvar linkPortB = targetNode.inputs[target.name];\r\n\t\t\t\t\t\t\tif(linkPortB === void 0){\r\n\t\t\t\t\t\t\t\tconsole.error(\"Node port not found for\", targetNode, \"with name:\", target.name);\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Create cable from NodeA\r\n\t\t\t\t\t\t\tvar rectA = getPortRect(node.outputs, portName);\r\n\t\t\t\t\t\t\tvar cable = linkPortA.createCable(rectA);\r\n\r\n\t\t\t\t\t\t\t// Positioning the cable head2 into target port position from NodeB\r\n\t\t\t\t\t\t\tvar rectB = getPortRect(targetNode.inputs, target.name);\r\n\t\t\t\t\t\t\tvar center = rectB.width/2;\r\n\t\t\t\t\t\t\tcable.head2 = [rectB.x+center, rectB.y+center];\r\n\r\n\t\t\t\t\t\t\t// Connect cables.currentCable to target port on NodeB\r\n\t\t\t\t\t\t\tlinkPortB.connectCable(cable);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Call handler init after creation processes was finished\r\n\t\tfor (var i = 0; i < handlers.length; i++)\r\n\t\t\thandlers[i].init && handlers[i].init();\r\n\r\n\t\treturn inserted;\r\n\t}\r\n\r\n\texportJSON(options){\r\n\t\tvar nodes = Blackprint.space.scope('nodes').list;\r\n\t\tvar json = {};\r\n\t\tvar exclude = options.exclude || [];\r\n\r\n\t\tfor (var i = 0; i < nodes.length; i++) {\r\n\t\t\tvar node = nodes[i];\r\n\t\t\tif(exclude.includes(node.namespace))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif(json[node.namespace] === void 0)\r\n\t\t\t\tjson[node.namespace] = [];\r\n\r\n\t\t\tvar data = {\r\n\t\t\t\tid:i,\r\n\t\t\t\tx:node.x,\r\n\t\t\t\ty:node.y,\r\n\t\t\t};\r\n\r\n\t\t\tif(node.options !== void 0)\r\n\t\t\t\tdata.options = node.options;\r\n\r\n\t\t\tif(node.outputs !== void 0){\r\n\t\t\t\tvar outputs = data.outputs = {};\r\n\t\t\t\tvar outputs_ = node.outputs;\r\n\r\n\t\t\t\tvar haveValue = false;\r\n\t\t\t\tfor(var name in outputs_){\r\n\t\t\t\t\tif(outputs[name] === void 0)\r\n\t\t\t\t\t\toutputs[name] = [];\r\n\r\n\t\t\t\t\tvar port = outputs_[name];\r\n\t\t\t\t\tvar cables = port.cables;\r\n\r\n\t\t\t\t\tfor (var a = 0; a < cables.length; a++) {\r\n\t\t\t\t\t\tvar target = cables[a].owner === port ? cables[a].target : cables[a].owner;\r\n\t\t\t\t\t\tif(target === void 0)\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\tvar id = nodes.indexOf(target.node);\r\n\t\t\t\t\t\tif(exclude.includes(nodes[id].namespace))\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thaveValue = true;\r\n\t\t\t\t\t\toutputs[name].push({\r\n\t\t\t\t\t\t\tid:id,\r\n\t\t\t\t\t\t\tname:target.name\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(haveValue === false)\r\n\t\t\t\t\tdelete data.outputs;\r\n\t\t\t}\r\n\r\n\t\t\tjson[node.namespace].push(data);\r\n\t\t}\r\n\r\n\t\treturn JSON.stringify(json);\r\n\t}\r\n\r\n\t// Create new node that will be inserted to the container\r\n\t// @return node scope\r\n\tcreateNode(namespace, options, handlers){\r\n\t\tvar func = deepProperty(Blackprint.nodes, namespace.split('/'));\r\n\t\tif(func === void 0)\r\n\t\t\treturn console.error('Node for', namespace, \"was not found, maybe .registerNode() haven't being called?\") && void 0;\r\n\r\n\t\t// Processing scope is different with node scope\r\n\t\tvar handle = {}, node = {type:'default', title:'No Title', description:''};\r\n\t\tnode.handle = handle;\r\n\t\tnode.namespace = namespace;\r\n\t\tnode.importing = true;\r\n\r\n\t\t// Call the registered func (from this.registerNode)\r\n\t\tfunc(handle, node);\r\n\r\n\t\tif(Blackprint.Interpreter.Node === void 0)\r\n\t\t\tthrow new Error(\"Blackprint.Interpreter was not found, please load it first before creating new node\");\r\n\r\n\t\t// Create the linker between the handler and the node\r\n\t\tBlackprint.Interpreter.Node.prepare(handle, node);\r\n\r\n\t\t// Replace port prototype (intepreter port -> visual port)\r\n\t\t['inputs', 'outputs', 'properties'].forEach(function(which){\r\n\t\t\tvar localPorts = node[which];\r\n\t\t\tfor(var portName in localPorts)\r\n\t\t\t\tObject.setPrototypeOf(localPorts[portName], Port.prototype);\r\n\t\t});\r\n\r\n\t\tBlackprint.Node.prepare(handle, node);\r\n\r\n\t\tvar savedOpt = options.options;\r\n\t\tdelete options.options;\r\n\r\n\t\t// Assign the node options if exist\r\n\t\tif(options !== void 0)\r\n\t\t\tObject.assign(node, options);\r\n\r\n\t\t// Node is become the component scope\r\n\t\t// equal to calling registerInterface's registered function\r\n\t\tthis.scope('nodes').list.push(node);\r\n\r\n\t\t// Assign the saved options if exist\r\n\t\tif(savedOpt !== void 0)\r\n\t\t\tObject.assign(node.options, savedOpt);\r\n\r\n\t\tnode.importing = false;\r\n\t\thandle.imported && handle.imported();\r\n\r\n\t\tif(handlers !== void 0)\r\n\t\t\thandlers.push(handle);\r\n\t\telse if(handle.init !== void 0)\r\n\t\t\thandle.init();\r\n\r\n\t\treturn node;\r\n\t}\r\n}\r\n\r\nBlackprint.nodes = {};\r\nBlackprint.index = 0;\r\nBlackprint.template = {\r\n\toutputPort:'Blackprint/nodes/template/output-port.html'\r\n};\r\n\r\n// Let's define `Space` that handle model and component as global variable on our private scope\r\nvar Space = Blackprint.space = sf.space('blackprint', {\r\n\ttemplatePath:'Blackprint/page.html'\r\n});",";(function(){\r\n\r\n// Private variable\r\nvar container;\r\n\r\n// Run when all ready\r\n$(function(){\r\n\tcontainer = Blackprint.space.scope('container');\r\n});\r\n\r\n// Private function\r\nfunction moveCables(node, e, which){\r\n\t// Move the connected cables\r\n\tfor(var key in which){\r\n\t\tvar cables = which[key].cables;\r\n\t\tif(cables.length === 0)\r\n\t\t\tcontinue;\r\n\r\n\t\tvar cable;\r\n\t\tfor (var a = 0; a < cables.length; a++) {\r\n\t\t\tif(cables[a].owner.node === node)\r\n\t\t\t\tcable = cables[a].head1;\r\n\t\t\telse\r\n\t\t\t\tcable = cables[a].head2;\r\n\r\n\t\t\tcable[0] += e.movementX / container.scale;\r\n\t\t\tcable[1] += e.movementY / container.scale;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nBlackprint.Node = class Node extends Blackprint.Interpreter.CustomEvent{\r\n\t/*\r\n\tx = 0;\r\n\ty = 0;\r\n\r\n\tinputs = {};\r\n\toutputs = {};\r\n\tproperties = {};\r\n\t*/\r\n\r\n\tstatic prepare(handle, node){\r\n\t\t// Default Node properties\r\n\t\tnode.x = 0;\r\n\t\tnode.y = 0;\r\n\t}\r\n\r\n\t// DragMove event handler\r\n\tmoveNode(e){\r\n\t\tthis.x += e.movementX / container.scale;\r\n\t\tthis.y += e.movementY / container.scale;\r\n\r\n\t\t// Also move all cable connected to current node\r\n\t\tmoveCables(this, e, this.inputs);\r\n\t\tmoveCables(this, e, this.outputs);\r\n\t\tmoveCables(this, e, this.properties);\r\n\t}\r\n\r\n\tnodeMenu(ev){\r\n\t\tvar menu = [{\r\n\t\t\ttitle:'Delete',\r\n\t\t\targs:[this],\r\n\t\t\tcallback:function(node){\r\n\t\t\t\tvar list = Blackprint.space.scope('nodes').list;\r\n\t\t\t\tvar i = list.indexOf(node);\r\n\r\n\t\t\t\tif(i === -1)\r\n\t\t\t\t\treturn console.error(\"Node was not found on the list\", node);\r\n\r\n\t\t\t\tlist.splice(i, 1);\r\n\r\n\t\t\t\tvar check = ['outputs', 'inputs', 'properties'];\r\n\t\t\t\tfor (var i = 0; i < check.length; i++) {\r\n\t\t\t\t\tvar portList = node[check[i]];\r\n\t\t\t\t\tfor(var port in portList){\r\n\t\t\t\t\t\tvar cables = portList[port].cables;\r\n\t\t\t\t\t\tfor (var a = cables.length - 1; a >= 0; a--)\r\n\t\t\t\t\t\t\tcables[a].destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}];\r\n\r\n\t\tthis._trigger('node.menu', {node:this, menu:menu});\r\n\t\tBlackprint.space.scope('dropdown').show(menu, ev.clientX, ev.clientY);\r\n\t}\r\n}\r\n\r\n})();","// Prepare for the future\r\nBlackprint.Function = class Function extends Blackprint.Node{\r\n\tstatic init(){}\r\n}","// Prepare for the future\r\nBlackprint.Input = class Input extends Blackprint.Node{\r\n\tstatic init(){}\r\n}","// Prepare for the future\r\nBlackprint.Trigger = class Trigger extends Blackprint.Node{\r\n\tstatic init(){}\r\n}","class Cable extends Blackprint.Interpreter.Cable{\r\n\tconstructor(obj, port){\r\n\t\tsuper(port);\r\n\r\n\t\tvar container = Blackprint.space.scope('container');\r\n\t\tvar Ofst = container.offset;\r\n\r\n\t\tthis.head1 = [\r\n\t\t\t(obj.x - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),\r\n\t\t\t(obj.y - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)\r\n\t\t];\r\n\r\n\t\tthis.head2 = [\r\n\t\t\t(obj.x - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),\r\n\t\t\t(obj.y - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)\r\n\t\t];\r\n\r\n\t\tthis.type = !port.type ? 'Any' : port.type.name\r\n\t\tthis.source = port.source;\r\n\t\tthis.valid = true;\r\n\t\tthis.linePath = '0 0 0 0';\r\n\r\n\t\t// Push to cable list\r\n\t\tBlackprint.space.scope('cables').list.push(this);\r\n\t}\r\n\r\n\tvisualizeFlow(){\r\n\t\tvar el = Blackprint.space.scope('cables').list.getElement(this);\r\n\t\tvar className;\r\n\r\n\t\tif(this.owner.source === 'outputs'){\r\n\t\t\tif(this.head1[0] < this.head2[0])\r\n\t\t\t\tclassName = 'line-flow';\r\n\t\t\telse className = 'line-flow-reverse';\r\n\t\t}\r\n\t\telse if(this.owner.source === 'inputs'){\r\n\t\t\tif(this.head1[0] > this.head2[0])\r\n\t\t\t\tclassName = 'line-flow';\r\n\t\t\telse className = 'line-flow-reverse';\r\n\t\t}\r\n\r\n\t\tel.classList.add(className);\r\n\t\tsetTimeout(function(){\r\n\t\t\tel.classList.remove(className);\r\n\t\t}, 1000);\r\n\t}\r\n\r\n\tcableHeadClicked(ev){\r\n\t\tvar container = Blackprint.space.scope('container');\r\n\t\tvar cablesModel = Blackprint.space.scope('cables');\r\n\r\n\t\tvar Ofst = container.offset;\r\n\t\tvar cable = this;\r\n\r\n\t\tfunction moveCableHead(ev){\r\n\t\t\t// Let's make a magnet sensation (fixed position when hovering node port)\r\n\t\t\tif(cablesModel.hoverPort !== false){\r\n\t\t\t\tvar center = cablesModel.hoverPort.rect.width/2;\r\n\t\t\t\tcable.head2 = [\r\n\t\t\t\t\t(cablesModel.hoverPort.rect.x+center - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),\r\n\t\t\t\t\t(cablesModel.hoverPort.rect.y+center - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)\r\n\t\t\t\t];\r\n\t\t\t}\r\n\r\n\t\t\t// Follow pointer\r\n\t\t\telse cable.head2 = [\r\n\t\t\t\t(ev.clientX - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),\r\n\t\t\t\t(ev.clientY - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\tvar elem = cablesModel.list.getElement(cable);\r\n\r\n\t\t// Let the pointer pass thru the current svg group\r\n\t\tif(elem !== void 0){\r\n\t\t\telem = $(elem);\r\n\t\t\telem.css('pointer-events', 'none');\r\n\t\t}\r\n\r\n\t\t// Save current cable for referencing when cable connected into node's port\r\n\t\tcablesModel.currentCable = cable;\r\n\t\t$('vw-sketch').on('pointermove', moveCableHead).once('pointerup', function(ev){\r\n\t\t\t$('vw-sketch').off('pointermove', moveCableHead);\r\n\r\n\t\t\t// Add delay because it may be used for connecting port\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\tcablesModel.currentCable = void 0;\r\n\t\t\t}, 100);\r\n\r\n\t\t\tif(elem !== void 0)\r\n\t\t\t\telem.css('pointer-events', '');\r\n\t\t});\r\n\t}\r\n\r\n\tcableMenu(ev){\r\n\t\tev.stopPropagation();\r\n\r\n\t\tBlackprint.space.scope('dropdown').show([{\r\n\t\t\ttitle:this.target ? \"Disconnect\" : \"Delete\",\r\n\t\t\tcontext:this,\r\n\t\t\tcallback:Cable.prototype.destroy,\r\n\t\t\thover:function(){\r\n\t\t\t\tthis.owner.node.$el.addClass('highlight');\r\n\r\n\t\t\t\tif(this.target)\r\n\t\t\t\t\tthis.target.node.$el.addClass('highlight');\r\n\t\t\t},\r\n\t\t\tunhover:function(){\r\n\t\t\t\tthis.owner.node.$el.removeClass('highlight');\r\n\r\n\t\t\t\tif(this.target)\r\n\t\t\t\t\tthis.target.node.$el.removeClass('highlight');\r\n\t\t\t}\r\n\t\t}], ev.clientX, ev.clientY);\r\n\t}\r\n\r\n\tdestroy(){\r\n\t\t// Remove from cable owner\r\n\t\tif(this.owner){\r\n\t\t\tvar i = this.owner.cables.indexOf(this);\r\n\t\t\tif(i !== -1)\r\n\t\t\t\tthis.owner.cables.splice(i, 1);\r\n\r\n\t\t\tthis.owner.node._trigger('cable.disconnect', this.target);\r\n\t\t}\r\n\r\n\t\t// Remove from connected target\r\n\t\tif(this.target){\r\n\t\t\tvar i = this.target.cables.indexOf(this);\r\n\t\t\tif(i !== -1)\r\n\t\t\t\tthis.target.cables.splice(i, 1);\r\n\r\n\t\t\tthis.target.node._trigger('cable.disconnect', this.owner);\r\n\t\t}\r\n\r\n\t\tvar list = Blackprint.space.scope('cables').list;\r\n\r\n\t\t// Remove from cable list\r\n\t\tlist.splice(list.indexOf(this), 1);\r\n\t\tconsole.log('A cable was removed', this);\r\n\t}\r\n}","class Port extends Blackprint.Interpreter.Port{\r\n\tcreateCable(e){\r\n\t\tvar isAuto = e.constructor === DOMRect;\r\n\r\n\t\t// Get size and position of the port\r\n\t\tvar rect = isAuto ? e : e.target.getBoundingClientRect();\r\n\t\tvar center = rect.width/2;\r\n\r\n\t\t// Create cable and save the reference\r\n\t\tvar cable = new Cable({\r\n\t\t\tx:rect.x + center,\r\n\t\t\ty:rect.y + center\r\n\t\t}, this);\r\n\r\n\t\t// Connect this cable into port's cable list\r\n\t\tthis.cables.push(cable);\r\n\r\n\t\t// Put port reference to the cable\r\n\t\tcable.owner = this;\r\n\r\n\t\t// Stop here if this function wasn't triggered by user\r\n\t\tif(isAuto)\r\n\t\t\treturn cable;\r\n\r\n\t\t// Default head index is \"2\" when creating new cable\r\n\t\tcable.cableHeadClicked(e);\r\n\t\tthis.node._trigger('cable.created', cable);\r\n\t}\r\n\r\n\tconnectCable(cable){\r\n\t\tif(cable === void 0)\r\n\t\t\tcable = Blackprint.space.scope('cables').currentCable;\r\n\r\n\t\t// It's not a cable might\r\n\t\tif(cable === void 0)\r\n\t\t\treturn;\r\n\r\n\t\t// Remove cable if ...\r\n\t\tif(cable.owner === this // It's referencing to same port\r\n\t\t\t|| (cable.source === 'outputs' && this.source !== 'inputs') // Output source not connected to input\r\n\t\t\t|| (cable.source === 'inputs' && this.source !== 'outputs')  // Input source not connected to output\r\n\t\t\t|| (cable.source === 'properties' && this.source !== 'properties')  // Property source not connected to property\r\n\t\t){\r\n\t\t\tconsole.log(`The cable is not suitable (${cable.source}, ${this.source})`);\r\n\t\t\tcable.destroy();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remove cable if type restriction\r\n\t\tif(cable.owner.type === Function && this.type !== Function\r\n\t\t   || cable.owner.type !== Function && this.type === Function\r\n\t\t){\r\n\t\t\tconsole.log(`The cable type is not suitable (${cable.owner.type.name}, ${this.type.name})`);\r\n\t\t\tcable.destroy();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar sourceCables = cable.owner.cables;\r\n\r\n\t\t// Remove cable if there are similar connection for the ports\r\n\t\tfor (var i = 0; i < sourceCables.length; i++) {\r\n\t\t\tif(this.cables.includes(sourceCables[i])){\r\n\t\t\t\tconsole.log(\"Duplicate connection\");\r\n\t\t\t\tcable.destroy();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Put port reference to the cable\r\n\t\tcable.target = this;\r\n\r\n\t\t// Connect this cable into port's cable list\r\n\t\tthis.cables.push(cable);\r\n\r\n\t\tthis.node._trigger('cable.connect', cable);\r\n\t\tcable.owner.node._trigger('cable.connect', cable, true);\r\n\t}\r\n\r\n\t// PointerOver event handler\r\n\tportHovered(event){\r\n\t\t// For magnet sensation when the cable reach the port\r\n\t\tBlackprint.space.scope('cables').hoverPort = {\r\n\t\t\telem:event.target,\r\n\t\t\trect:event.target.getBoundingClientRect(),\r\n\t\t\titem:this\r\n\t\t};\r\n\t}\r\n\r\n\t// PointerOut event handler\r\n\tportUnhovered(){\r\n\t\tBlackprint.space.scope('cables').hoverPort = false;\r\n\t}\r\n\r\n\tportRightClick(ev){\r\n\t\tvar menu = [];\r\n\t\tthis.node._trigger('port.menu', {port:this, menu:menu});\r\n\r\n\t\t// Prepare default menu\r\n\t\tvar disconnect = {title:\"Disconnect\", deep:[]};\r\n\r\n\t\tvar cables = this.cables;\r\n\t\tfor (var i = 0; i < cables.length; i++) {\r\n\t\t\tlet target = cables[i].owner === this ? cables[i].target : cables[i].owner;\r\n\t\t\tif(target === void 0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tdisconnect.deep.push({\r\n\t\t\t\ttitle:target.node.title+`(${this.name} ~ ${target.name})`,\r\n\t\t\t\tcontext:cables[i],\r\n\t\t\t\tcallback:Cable.prototype.destroy,\r\n\t\t\t\thover:function(){\r\n\t\t\t\t\tBlackprint.space.scope('cables').list.getElement(this).classList.add('highlight');\r\n\r\n\t\t\t\t\ttarget.node.$el.addClass('highlight');\r\n\t\t\t\t},\r\n\t\t\t\tunhover:function(){\r\n\t\t\t\t\tBlackprint.space.scope('cables').list.getElement(this).classList.remove('highlight');\r\n\r\n\t\t\t\t\ttarget.node.$el.removeClass('highlight');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(disconnect.deep.length !== 0)\r\n\t\t\tmenu.push(disconnect);\r\n\r\n\t\tif(menu.length === 0)\r\n\t\t\treturn;\r\n\r\n\t\tvar pos = ev.target.getClientRects()[0];\r\n\t\tBlackprint.space.scope('dropdown').show(menu, pos.x, pos.y);\r\n\t}\r\n}","// RepeatedProperty: from node inputs, outputs, or properties list\r\nfunction getPortRect(RP, name){\r\n\tif(RP.getElement === void 0)\r\n\t\tconsole.error(\"It seems the JSON was imported when sketch view haven't been loaded\");\r\n\r\n\treturn RP.getElement(name).querySelector('.port').getBoundingClientRect();\r\n}\r\n\r\nfunction deepProperty(obj, path, value){\r\n\tif(value !== void 0){\r\n\t\tfor(var i = 0, n = path.length-1; i < n; i++){\r\n\t\t\tif(obj[path[i]] === void 0)\r\n\t\t\t\tobj[path[i]] = {};\r\n\r\n\t\t\tobj = obj[path[i]];\r\n\t\t}\r\n\r\n\t\tobj[path[i]] = value;\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor(var i = 0; i < path.length; i++){\r\n\t\tobj = obj[path[i]];\r\n\r\n\t\tif(obj === void 0)\r\n\t\t\treturn;\r\n\t}\r\n\r\n\treturn obj;\r\n}","Space.model('cables', function(self, root){\r\n\t// any item will be: ../constructor/Cable.js\r\n\tself.list = [];\r\n\r\n\tself.container = root('container');\r\n\r\n\t// Fixing viewport position\r\n\tself.space = [0,0];\r\n\tself.init = function(){\r\n\t\tsetTimeout(function(){\r\n\t\t\t// Get sf-space element\r\n\t\t\tvar rect = self.$el[0].parentNode.getBoundingClientRect();\r\n\t\t\tself.space = [rect.x, rect.y];\r\n\t\t}, 500);\r\n\t}\r\n\r\n\t// Flag if cursor was hovering a node port\r\n\tself.hoverPort = false; // {elem:, item:}\r\n\r\n\t// Move clicked cable\r\n\tself.currentCable = void 0;\r\n\r\n\t// This will run everytime the cable was moving\r\n\t// used on: ../page.html\r\n\tself.recalculatePath = function(item){\r\n\t\tvar x1 = item.head1[0], y1 = item.head1[1];\r\n\t\tvar x2 = item.head2[0], y2 = item.head2[1];\r\n\r\n\t\t// Written without formula, just logic...\r\n\t\tif(item.source !== 'properties'){\r\n\t\t\tvar cx = (x2-x1)/2;\r\n\t\t\tif(cx > -50 && cx < 0)\r\n\t\t\t\tcx = -50;\r\n\t\t\telse if(cx < 50 && cx >= 0)\r\n\t\t\t\tcx = 50;\r\n\r\n\t\t\tif(item.source === 'inputs'){\r\n\t\t\t\tif(x2 < x1)\r\n\t\t\t\t  item.linePath = `${x1 + cx} ${y1} ${x2 - cx} ${y2}`;\r\n\t\t\t\telse\r\n\t\t\t\t  item.linePath = `${x1 - cx} ${y1} ${x2 + cx} ${y2}`;\r\n\t\t\t}\r\n\t\t\telse if(item.source === 'outputs'){\r\n\t\t\t\tif(x2 < x1)\r\n\t\t\t\t  item.linePath = `${x1 - cx} ${y1} ${x2 + cx} ${y2}`;\r\n\t\t\t\telse\r\n\t\t\t\t  item.linePath = `${x1 + cx} ${y1} ${x2 - cx} ${y2}`;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t\tvar cy = (y2-y1)/2;\r\n\t\t\tif(cy > -50 && cy < 0)\r\n\t\t\t\tcy = -50;\r\n\t\t\telse if(cy < 50 && cy >= 0)\r\n\t\t\t\tcy = 50;\r\n\r\n\t\t\tif(y2 < y1)\r\n\t\t\t  item.linePath = `${x1} ${y1 - cy} ${x2} ${y2 - cy}`;\r\n\t\t\telse\r\n\t\t\t  item.linePath = `${x1} ${y1 + cy} ${x2} ${y2 + cy}`;\r\n\t\t}\r\n\t}\r\n});","Space.model('container', function(self, root){\r\n\tself.cableScope = root('cables');\r\n\tself.nodeScope = root('nodes');\r\n\r\n\tfunction onlyNegative(old, now){\r\n\t\tif(now > 0) return 0;\r\n\t}\r\n\r\n\tself.pos = {x:0, y:0,\r\n\t\t// Because origin is top left, viewport height and width are increased on bottom right\r\n\t\t// Force to zero if there are no more space to be panned on left side\r\n\t\ton$x: onlyNegative, on$y: onlyNegative\r\n\t};\r\n\r\n\tself.scale = 1;\r\n\tself.size = {w:0, h:0};\r\n\tself.origSize = {w:0, h:0};\r\n\tself.offset;\r\n\r\n\tself.init = function(){\r\n\t\tself.resetOffset();\r\n\t\tself.size.w = self.offset.width;\r\n\t\tself.size.h = self.offset.height;\r\n\t}\r\n\r\n\tself.resetOffset = function(){\r\n\t\tself.$el.css({\r\n\t\t\twidth:'100%',\r\n\t\t\theight:'100%'\r\n\t\t});\r\n\r\n\t\tself.offset = self.$el[0].getBoundingClientRect();\r\n\t\tself.origSize.w = self.offset.width;\r\n\t\tself.origSize.h = self.offset.height;\r\n\t}\r\n\r\n\tfunction moveContainer(ev){\r\n\t\tif(!(self.pos.x >= 0 && ev.movementX > 0)){\r\n\t\t\tself.size.w -= ev.movementX;\r\n\t\t\tself.pos.x += ev.movementX;\r\n\t\t}\r\n\r\n\t\tif(!(self.pos.y >= 0 && ev.movementY > 0)){\r\n\t\t\tself.size.h -= ev.movementY;\r\n\t\t\tself.pos.y += ev.movementY;\r\n\t\t}\r\n\t}\r\n\r\n\tself.moveContainer = function(ev){\r\n\t\tself.$el.on('pointermove', moveContainer).on('pointerup', function(){\r\n\t\t\tself.$el.off('pointermove', moveContainer);\r\n\t\t});\r\n\t}\r\n\r\n\tself.scaleContainer = function(ev){\r\n\t\tif(ev.deltaY > 0 && self.scale <= 0.2)\r\n\t\t\treturn;\r\n\r\n\t\tif(ev.deltaY < 0 && self.scale >= 2)\r\n\t\t\treturn;\r\n\r\n\t\tvar delta = ev.deltaY/100 * 0.08;\r\n\t\tself.scale -= delta;\r\n\r\n\t\t// ToDo: fix scaling, should scale with cursor as the middle scaling position\r\n\t\tself.pos.x += ev.clientX * delta;\r\n\t\tself.pos.y += ev.clientY * delta;\r\n\r\n\t\t// self.pos will always negative or zero value\r\n\t\t// hint on the object declaration\r\n\r\n\t\tself.size.w = self.origSize.w / self.scale - self.pos.x;\r\n\t\tself.size.h = self.origSize.h / self.scale - self.pos.y;\r\n\t}\r\n});","Space.component('drop-down', {template:\"Blackprint/container/drop-down.html\"}, function(self, root, $item){\r\n\tself.visible = false;\r\n\r\n\tself.options = $item;\r\n\tself.x = $item.x;\r\n\tself.y = $item.y;\r\n\r\n\tvar currentDeepLevel;\r\n\tself.init = function(){\r\n\t\tvar elem = self.$el[0].firstElementChild;\r\n\r\n\t\tif(self.x + elem.offsetWidth > window.innerWidth)\r\n\t\t\tself.x -= elem.offsetWidth;\r\n\r\n\t\tif(self.y + elem.offsetHeight > window.innerHeight)\r\n\t\t\tself.y -= elem.offsetHeight;\r\n\r\n\t\tself.visible = true;\r\n\r\n\t\t// Find nested options and add event listener on mouse hover\r\n\t\tvar options = self.options;\r\n\t\tfor (let i = 0; i < options.length; i++) {\r\n\t\t\tif(options[i].deep !== void 0){\r\n\t\t\t\t$(options.getElement(i)).on('mouseover', function(ev){\r\n\t\t\t\t\tif(currentDeepLevel !== void 0)\r\n\t\t\t\t\t\tself.deepRemove();\r\n\r\n\t\t\t\t\tif(options[i].hover !== void 0)\r\n\t\t\t\t\t\toptions[i].hover.apply(options[i].context, options[i].args);\r\n\r\n\t\t\t\t\tvar deep = options[i].deep;\r\n\r\n\t\t\t\t\t// Use the cache instead\r\n\t\t\t\t\tif(deep.el !== void 0){\r\n\t\t\t\t\t\tcurrentDeepLevel = deep.el;\r\n\t\t\t\t\t\tself.$el.append(deep.el);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Initialize position once\r\n\t\t\t\t\tvar rect = ev.target.getBoundingClientRect();\r\n\t\t\t\t\tdeep.x = rect.left + rect.width;\r\n\t\t\t\t\tdeep.y = rect.top - rect.height/2 + 7;\r\n\r\n\t\t\t\t\tdeep.el = currentDeepLevel = new $DropDown(deep, Blackprint.space);\r\n\t\t\t\t\tself.$el.append(currentDeepLevel);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tvar elem = $(options.getElement(i));\r\n\r\n\t\t\tif(options[i].callback){\r\n\t\t\t\telem.on('click', function(ev){\r\n\t\t\t\t\tif(options[i].unhover !== void 0)\r\n\t\t\t\t\t\toptions[i].unhover.apply(options[i].context, options[i].args);\r\n\r\n\t\t\t\t\toptions[i].callback.apply(options[i].context, options[i].args);\r\n\t\t\t\t\troot('dropdown').hide();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif(options[i].hover){\r\n\t\t\t\telem.on('mouseover', function(ev){\r\n\t\t\t\t\toptions[i].hover.apply(options[i].context, options[i].args);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif(options[i].unhover){\r\n\t\t\t\telem.on('mouseout', function(ev){\r\n\t\t\t\t\toptions[i].unhover.apply(options[i].context, options[i].args);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tself.deepRemove = function(){\r\n\t\tif(currentDeepLevel === void 0)\r\n\t\t\treturn;\r\n\r\n\t\tcurrentDeepLevel.remove();\r\n\t\tcurrentDeepLevel.model.deepRemove();\r\n\t}\r\n});","Space.model('dropdown', function(self){\r\n\tself.menus = [];\r\n\tself.onCancel = void 0;\r\n\r\n\t// options: [{title, callback}, {title, deep:[{...}]}, ...]\r\n\tself.show = function(options, x, y){\r\n\t\t// Remove last dropdown if haven't been closed\r\n\t\tif(self.menus.length !== 0)\r\n\t\t\tself.menus.splice(0);\r\n\t\telse\r\n\t\t\tmanageBackdrop(true);\r\n\r\n\t\toptions.x = x;\r\n\t\toptions.y = y;\r\n\t\tself.menus.push(options);\r\n\r\n\t\treturn self;\r\n\t}\r\n\r\n\tself.hide = function(){\r\n\t\tfor (var i = 0; i < self.menus.length; i++)\r\n\t\t\tself.menus.getElement(i).model.deepRemove();\r\n\r\n\t\tself.menus.splice(0);\r\n\t}\r\n\r\n\tvar backdropCreated = false;\r\n\tfunction backdropListener(ev){\r\n\t\tif($(ev.target).parent('sf-m')[0] === self.$el[0])\r\n\t\t\treturn;\r\n\r\n\t\tbackdropCreated = false;\r\n\r\n\t\tself.hide();\r\n\t\t$('body').off('click', backdropListener);\r\n\t\tself.onCancel && self.onCancel();\r\n\t}\r\n\r\n\tfunction manageBackdrop(isAdd){\r\n\t\tsetTimeout(function(){\r\n\t\t\tif(isAdd){\r\n\t\t\t\tif(!backdropCreated){\r\n\t\t\t\t\t$('body').on('click', backdropListener);\r\n\t\t\t\t\tbackdropCreated = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t$('body').off('click', backdropListener);\r\n\t\t\t\tbackdropCreated = false;\r\n\t\t\t}\r\n\t\t}, 10);\r\n\t}\r\n});","Space.model('nodes', function(self, root){\r\n\tself.list = [];\r\n\r\n\tfunction createNode(namespace){\r\n\t\tsketch.createNode(namespace, {x:menuEv.layerX, y:menuEv.layerY});\r\n\t}\r\n\r\n\tvar menuEv;\r\n\tself.menu = function(ev){\r\n\t\tev.preventDefault();\r\n\t\tmenuEv = ev;\r\n\r\n\t\tvar namespaces = Blackprint.nodes;\r\n\r\n\t\tvar menu = [];\r\n\t\tvar strArr = [];\r\n\t\tfunction deep(obj, target){\r\n\t\t\tfor(var name in obj){\r\n\t\t\t\tif(obj[name].constructor === Function){\r\n\t\t\t\t\ttarget.push({\r\n\t\t\t\t\t\ttitle:name,\r\n\t\t\t\t\t\targs:[strArr.length !== 0 ? strArr.join('/')+'/'+name : name],\r\n\t\t\t\t\t\tcallback:createNode\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar newMenu = [];\r\n\t\t\t\ttarget.push({title:name, deep:newMenu});\r\n\r\n\t\t\t\tstrArr.push(name);\r\n\t\t\t\tdeep(obj[name], newMenu);\r\n\t\t\t\tstrArr.pop();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdeep(namespaces, menu);\r\n\t\troot('dropdown').show(menu, ev.clientX, ev.clientY);\r\n\t}\r\n});","Space.component('default-node', {\r\n\textend: Blackprint.Node,\r\n\ttemplate:'Blackprint/nodes/default.html'\r\n}, function(self, root){\r\n\t// Property of this scope\r\n\t/* self == {\r\n\t\tx: 0,\r\n\t\ty: 0,\r\n\t\tinputs: [],\r\n\t\toutputs: [],\r\n\t\tproperties: [],\r\n\t} */\r\n});","return Blackprint;\r\n})));\r\n// End of compiled file"]}