/* Blackprint 
 MIT Licensed */
// Start private scope for Blackprint Module
;(function(global, factory){
  if(typeof exports === 'object' && typeof module !== 'undefined')
  	return module.exports = factory(global);
  factory(global);
}(typeof window !== "undefined" ? window : this, (function(window){

if(window.Blackprint === void 0)
	window.Blackprint = {
		settings:function(which, val){
			Blackprint.settings[which] = val;
		}
	};

var Blackprint = window.Blackprint;

Blackprint.Sketch = class Sketch{
	// Create new blackprint container
	constructor(){
		this.index = Blackprint.index++;
		this.scope = Blackprint.space.getScope(this.index);
	}

	settings(which, val){
		Blackprint.settings[which] = val;
	}

	// Clone current container index
	cloneContainer(index){
		return Blackprint.space.getHTML(index || Blackprint.index);
	}

	// Register node handler
	// Callback function will get handle and node
	// - handle = Blackprint binding
	// - node = ScarletsFrame binding <~> element
	registerNode(namespace, func){
		deepProperty(Blackprint.nodes, namespace.split('/'), func);
	}

	// Register new node type
	registerInterface(nodeType, options, func){
		if(/[^\w\-]/.test(nodeType) !== false)
			return console.error("nodeType can only contain character a-zA-Z0-9 and dashes");

		if(options.extend === void 0 || options.template === void 0)
			throw new Error("Please define the node template and the extend options");

		if(!(options.extend.prototype instanceof Blackprint.Node))
			throw new Error(options.extend.constructor.name+" must be instance of Blackprint.Node");

		// Just like how we do it on ScarletsFrame component with namespace feature
		Blackprint.space.component(nodeType+'-node', options, func);
	}

	// Import node positions and cable connection from JSON
	importJSON(json){
		if(json.constructor === String)
			json = JSON.parse(json);

		var version = json.version;
		delete json.version;

		var inserted = [];
		var handlers = [];

		// Prepare all nodes depend on the namespace
		// before we create cables for them
		for(var namespace in json){
			var nodes = json[namespace];

			// Every nodes that using this namespace name
			for (var a = 0; a < nodes.length; a++){
				var nodeOpt = {
					x:nodes[a].x,
					y:nodes[a].y
				};

				if(nodes[a].options !== void 0)
					nodeOpt.options = nodes[a].options;

				inserted[nodes[a].id] = this.createNode(namespace, nodeOpt, handlers);
			}
		}

		// Create cable only from outputs and properties
		// > Important to be separated from above, so the cable can reference to loaded nodes
		for(var namespace in json){
			var nodes = json[namespace];

			// Every nodes that using this namespace name
			for (var a = 0; a < nodes.length; a++){
				var node = inserted[nodes[a].id];

				// If have outputs connection
				if(nodes[a].outputs !== void 0){
					var out = nodes[a].outputs;

					// Every outputs port that have connection
					for(var portName in out){
						var linkPortA = node.outputs[portName];
						if(linkPortA === void 0){
							console.error("Node port not found for", node, "with name:", portName);
							continue;
						}

						var port = out[portName];

						// Current outputs's available targets
						for (var k = 0; k < port.length; k++) {
							var target = port[k];
							var targetNode = inserted[target.id];

							// Outputs can only meet input port
							var linkPortB = targetNode.inputs[target.name];
							if(linkPortB === void 0){
								console.error("Node port not found for", targetNode, "with name:", target.name);
								continue;
							}

							// Create cable from NodeA
							var rectA = getPortRect(node.outputs, portName);
							var cable = linkPortA.createCable(rectA);

							// Positioning the cable head2 into target port position from NodeB
							var rectB = getPortRect(targetNode.inputs, target.name);
							var center = rectB.width/2;
							cable.head2 = [rectB.x+center, rectB.y+center];

							// Connect cables.currentCable to target port on NodeB
							linkPortB.connectCable(cable);
						}
					}
				}
			}
		}

		// Call handler init after creation processes was finished
		for (var i = 0; i < handlers.length; i++)
			handlers[i].init && handlers[i].init();

		return inserted;
	}

	exportJSON(options){
		var nodes = Blackprint.space.scope('nodes').list;
		var json = {};
		var exclude = options.exclude || [];

		for (var i = 0; i < nodes.length; i++) {
			var node = nodes[i];
			if(exclude.includes(node.namespace))
				continue;

			if(json[node.namespace] === void 0)
				json[node.namespace] = [];

			var data = {
				id:i,
				x:node.x,
				y:node.y,
			};

			if(node.options !== void 0)
				data.options = node.options;

			if(node.outputs !== void 0){
				var outputs = data.outputs = {};
				var outputs_ = node.outputs;

				var haveValue = false;
				for(var name in outputs_){
					if(outputs[name] === void 0)
						outputs[name] = [];

					var port = outputs_[name];
					var cables = port.cables;

					for (var a = 0; a < cables.length; a++) {
						var target = cables[a].owner === port ? cables[a].target : cables[a].owner;
						if(target === void 0)
							continue;

						var id = nodes.indexOf(target.node);
						if(exclude.includes(nodes[id].namespace))
							continue;

						haveValue = true;
						outputs[name].push({
							id:id,
							name:target.name
						});
					}
				}

				if(haveValue === false)
					delete data.outputs;
			}

			json[node.namespace].push(data);
		}

		return JSON.stringify(json);
	}

	// Create new node that will be inserted to the container
	// @return node scope
	createNode(namespace, options, handlers){
		var func = deepProperty(Blackprint.nodes, namespace.split('/'));
		if(func === void 0)
			return console.error('Node for', namespace, "was not found, maybe .registerNode() haven't being called?") && void 0;

		// Processing scope is different with node scope
		var handle = {}, node = {type:'default', title:'No Title', description:''};
		node.handle = handle;
		node.namespace = namespace;
		node.importing = true;

		// Call the registered func (from this.registerNode)
		func(handle, node);

		if(Blackprint.Interpreter.Node === void 0)
			throw new Error("Blackprint.Interpreter was not found, please load it first before creating new node");

		// Create the linker between the handler and the node
		Blackprint.Interpreter.Node.prepare(handle, node);

		// Replace port prototype (intepreter port -> visual port)
		['inputs', 'outputs', 'properties'].forEach(function(which){
			var localPorts = node[which];
			for(var portName in localPorts)
				Object.setPrototypeOf(localPorts[portName], Port.prototype);
		});

		Blackprint.Node.prepare(handle, node);

		var savedOpt = options.options;
		delete options.options;

		// Assign the node options if exist
		if(options !== void 0)
			Object.assign(node, options);

		// Node is become the component scope
		// equal to calling registerInterface's registered function
		this.scope('nodes').list.push(node);

		// Assign the saved options if exist
		if(savedOpt !== void 0)
			Object.assign(node.options, savedOpt);

		node.importing = false;
		handle.imported && handle.imported();

		if(handlers !== void 0)
			handlers.push(handle);
		else if(handle.init !== void 0)
			handle.init();

		return node;
	}
}

Blackprint.nodes = {};
Blackprint.index = 0;
Blackprint.template = {
	outputPort:'Blackprint/nodes/template/output-port.html'
};

// Let's define `Space` that handle model and component as global variable on our private scope
var Space = Blackprint.space = sf.space('blackprint', {
	templatePath:'Blackprint/page.html'
});
;(function(){

// Private variable
var container;

// Run when all ready
$(function(){
	container = Blackprint.space.scope('container');
});

// Private function
function moveCables(node, e, which){
	// Move the connected cables
	for(var key in which){
		var cables = which[key].cables;
		if(cables.length === 0)
			continue;

		var cable;
		for (var a = 0; a < cables.length; a++) {
			if(cables[a].owner.node === node)
				cable = cables[a].head1;
			else
				cable = cables[a].head2;

			cable[0] += e.movementX / container.scale;
			cable[1] += e.movementY / container.scale;
		}
	}
}

Blackprint.Node = class Node extends Blackprint.Interpreter.CustomEvent{
	/*
	x = 0;
	y = 0;

	inputs = {};
	outputs = {};
	properties = {};
	*/

	static prepare(handle, node){
		// Default Node properties
		node.x = 0;
		node.y = 0;
	}

	// DragMove event handler
	moveNode(e){
		this.x += e.movementX / container.scale;
		this.y += e.movementY / container.scale;

		// Also move all cable connected to current node
		moveCables(this, e, this.inputs);
		moveCables(this, e, this.outputs);
		moveCables(this, e, this.properties);
	}

	nodeMenu(ev){
		var menu = [{
			title:'Delete',
			args:[this],
			callback:function(node){
				var list = Blackprint.space.scope('nodes').list;
				var i = list.indexOf(node);

				if(i === -1)
					return console.error("Node was not found on the list", node);

				list.splice(i, 1);

				var check = ['outputs', 'inputs', 'properties'];
				for (var i = 0; i < check.length; i++) {
					var portList = node[check[i]];
					for(var port in portList){
						var cables = portList[port].cables;
						for (var a = cables.length - 1; a >= 0; a--)
							cables[a].destroy();
					}
				}
			}
		}];

		this._trigger('node.menu', {node:this, menu:menu});
		Blackprint.space.scope('dropdown').show(menu, ev.clientX, ev.clientY);
	}
}

})();
// Prepare for the future
Blackprint.Function = class Function extends Blackprint.Node{
	static init(){}
}
// Prepare for the future
Blackprint.Input = class Input extends Blackprint.Node{
	static init(){}
}
// Prepare for the future
Blackprint.Trigger = class Trigger extends Blackprint.Node{
	static init(){}
}
class Cable extends Blackprint.Interpreter.Cable{
	constructor(obj, port){
		super(port);

		var container = Blackprint.space.scope('container');
		var Ofst = container.offset;

		this.head1 = [
			(obj.x - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),
			(obj.y - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)
		];

		this.head2 = [
			(obj.x - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),
			(obj.y - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)
		];

		this.type = !port.type ? 'Any' : port.type.name
		this.source = port.source;
		this.valid = true;
		this.linePath = '0 0 0 0';

		// Push to cable list
		Blackprint.space.scope('cables').list.push(this);
	}

	visualizeFlow(){
		var el = Blackprint.space.scope('cables').list.getElement(this);
		var className;

		if(this.owner.source === 'outputs'){
			if(this.head1[0] < this.head2[0])
				className = 'line-flow';
			else className = 'line-flow-reverse';
		}
		else if(this.owner.source === 'inputs'){
			if(this.head1[0] > this.head2[0])
				className = 'line-flow';
			else className = 'line-flow-reverse';
		}

		el.classList.add(className);
		setTimeout(function(){
			el.classList.remove(className);
		}, 1000);
	}

	cableHeadClicked(ev){
		var container = Blackprint.space.scope('container');
		var cablesModel = Blackprint.space.scope('cables');

		var Ofst = container.offset;
		var cable = this;

		function moveCableHead(ev){
			// Let's make a magnet sensation (fixed position when hovering node port)
			if(cablesModel.hoverPort !== false){
				var center = cablesModel.hoverPort.rect.width/2;
				cable.head2 = [
					(cablesModel.hoverPort.rect.x+center - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),
					(cablesModel.hoverPort.rect.y+center - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)
				];
			}

			// Follow pointer
			else cable.head2 = [
				(ev.clientX - container.pos.x) / container.scale + (Ofst.x + -Ofst.x/container.scale),
				(ev.clientY - container.pos.y) / container.scale + (Ofst.y + -Ofst.y/container.scale)
			];
		}

		var elem = cablesModel.list.getElement(cable);

		// Let the pointer pass thru the current svg group
		if(elem !== void 0){
			elem = $(elem);
			elem.css('pointer-events', 'none');
		}

		// Save current cable for referencing when cable connected into node's port
		cablesModel.currentCable = cable;
		$('vw-sketch').on('pointermove', moveCableHead).once('pointerup', function(ev){
			$('vw-sketch').off('pointermove', moveCableHead);

			// Add delay because it may be used for connecting port
			setTimeout(function(){
				cablesModel.currentCable = void 0;
			}, 100);

			if(elem !== void 0)
				elem.css('pointer-events', '');
		});
	}

	cableMenu(ev){
		ev.stopPropagation();

		Blackprint.space.scope('dropdown').show([{
			title:this.target ? "Disconnect" : "Delete",
			context:this,
			callback:Cable.prototype.destroy,
			hover:function(){
				this.owner.node.$el.addClass('highlight');

				if(this.target)
					this.target.node.$el.addClass('highlight');
			},
			unhover:function(){
				this.owner.node.$el.removeClass('highlight');

				if(this.target)
					this.target.node.$el.removeClass('highlight');
			}
		}], ev.clientX, ev.clientY);
	}

	destroy(){
		// Remove from cable owner
		if(this.owner){
			var i = this.owner.cables.indexOf(this);
			if(i !== -1)
				this.owner.cables.splice(i, 1);

			this.owner.node._trigger('cable.disconnect', this.target);
		}

		// Remove from connected target
		if(this.target){
			var i = this.target.cables.indexOf(this);
			if(i !== -1)
				this.target.cables.splice(i, 1);

			this.target.node._trigger('cable.disconnect', this.owner);
		}

		var list = Blackprint.space.scope('cables').list;

		// Remove from cable list
		list.splice(list.indexOf(this), 1);
		console.log('A cable was removed', this);
	}
}
class Port extends Blackprint.Interpreter.Port{
	createCable(e){
		var isAuto = e.constructor === DOMRect;

		// Get size and position of the port
		var rect = isAuto ? e : e.target.getBoundingClientRect();
		var center = rect.width/2;

		// Create cable and save the reference
		var cable = new Cable({
			x:rect.x + center,
			y:rect.y + center
		}, this);

		// Connect this cable into port's cable list
		this.cables.push(cable);

		// Put port reference to the cable
		cable.owner = this;

		// Stop here if this function wasn't triggered by user
		if(isAuto)
			return cable;

		// Default head index is "2" when creating new cable
		cable.cableHeadClicked(e);
		this.node._trigger('cable.created', cable);
	}

	connectCable(cable){
		if(cable === void 0)
			cable = Blackprint.space.scope('cables').currentCable;

		// It's not a cable might
		if(cable === void 0)
			return;

		// Remove cable if ...
		if(cable.owner === this // It's referencing to same port
			|| (cable.source === 'outputs' && this.source !== 'inputs') // Output source not connected to input
			|| (cable.source === 'inputs' && this.source !== 'outputs')  // Input source not connected to output
			|| (cable.source === 'properties' && this.source !== 'properties')  // Property source not connected to property
		){
			console.log(`The cable is not suitable (${cable.source}, ${this.source})`);
			cable.destroy();
			return;
		}

		// Remove cable if type restriction
		if(cable.owner.type === Function && this.type !== Function
		   || cable.owner.type !== Function && this.type === Function
		){
			console.log(`The cable type is not suitable (${cable.owner.type.name}, ${this.type.name})`);
			cable.destroy();
			return;
		}

		var sourceCables = cable.owner.cables;

		// Remove cable if there are similar connection for the ports
		for (var i = 0; i < sourceCables.length; i++) {
			if(this.cables.includes(sourceCables[i])){
				console.log("Duplicate connection");
				cable.destroy();
				return;
			}
		}

		// Put port reference to the cable
		cable.target = this;

		// Connect this cable into port's cable list
		this.cables.push(cable);

		this.node._trigger('cable.connect', cable);
		cable.owner.node._trigger('cable.connect', cable, true);
	}

	// PointerOver event handler
	portHovered(event){
		// For magnet sensation when the cable reach the port
		Blackprint.space.scope('cables').hoverPort = {
			elem:event.target,
			rect:event.target.getBoundingClientRect(),
			item:this
		};
	}

	// PointerOut event handler
	portUnhovered(){
		Blackprint.space.scope('cables').hoverPort = false;
	}

	portRightClick(ev){
		var menu = [];
		this.node._trigger('port.menu', {port:this, menu:menu});

		// Prepare default menu
		var disconnect = {title:"Disconnect", deep:[]};

		var cables = this.cables;
		for (var i = 0; i < cables.length; i++) {
			let target = cables[i].owner === this ? cables[i].target : cables[i].owner;
			if(target === void 0)
				continue;

			disconnect.deep.push({
				title:target.node.title+`(${this.name} ~ ${target.name})`,
				context:cables[i],
				callback:Cable.prototype.destroy,
				hover:function(){
					Blackprint.space.scope('cables').list.getElement(this).classList.add('highlight');

					target.node.$el.addClass('highlight');
				},
				unhover:function(){
					Blackprint.space.scope('cables').list.getElement(this).classList.remove('highlight');

					target.node.$el.removeClass('highlight');
				}
			});
		}

		if(disconnect.deep.length !== 0)
			menu.push(disconnect);

		if(menu.length === 0)
			return;

		var pos = ev.target.getClientRects()[0];
		Blackprint.space.scope('dropdown').show(menu, pos.x, pos.y);
	}
}
// RepeatedProperty: from node inputs, outputs, or properties list
function getPortRect(RP, name){
	if(RP.getElement === void 0)
		console.error("It seems the JSON was imported when sketch view haven't been loaded");

	return RP.getElement(name).querySelector('.port').getBoundingClientRect();
}

function deepProperty(obj, path, value){
	if(value !== void 0){
		for(var i = 0, n = path.length-1; i < n; i++){
			if(obj[path[i]] === void 0)
				obj[path[i]] = {};

			obj = obj[path[i]];
		}

		obj[path[i]] = value;
		return;
	}

	for(var i = 0; i < path.length; i++){
		obj = obj[path[i]];

		if(obj === void 0)
			return;
	}

	return obj;
}
Space.model('cables', function(self, root){
	// any item will be: ../constructor/Cable.js
	self.list = [];

	self.container = root('container');

	// Fixing viewport position
	self.space = [0,0];
	self.init = function(){
		setTimeout(function(){
			// Get sf-space element
			var rect = self.$el[0].parentNode.getBoundingClientRect();
			self.space = [rect.x, rect.y];
		}, 500);
	}

	// Flag if cursor was hovering a node port
	self.hoverPort = false; // {elem:, item:}

	// Move clicked cable
	self.currentCable = void 0;

	// This will run everytime the cable was moving
	// used on: ../page.html
	self.recalculatePath = function(item){
		var x1 = item.head1[0], y1 = item.head1[1];
		var x2 = item.head2[0], y2 = item.head2[1];

		// Written without formula, just logic...
		if(item.source !== 'properties'){
			var cx = (x2-x1)/2;
			if(cx > -50 && cx < 0)
				cx = -50;
			else if(cx < 50 && cx >= 0)
				cx = 50;

			if(item.source === 'inputs'){
				if(x2 < x1)
				  item.linePath = `${x1 + cx} ${y1} ${x2 - cx} ${y2}`;
				else
				  item.linePath = `${x1 - cx} ${y1} ${x2 + cx} ${y2}`;
			}
			else if(item.source === 'outputs'){
				if(x2 < x1)
				  item.linePath = `${x1 - cx} ${y1} ${x2 + cx} ${y2}`;
				else
				  item.linePath = `${x1 + cx} ${y1} ${x2 - cx} ${y2}`;
			}
		}
		else{
			var cy = (y2-y1)/2;
			if(cy > -50 && cy < 0)
				cy = -50;
			else if(cy < 50 && cy >= 0)
				cy = 50;

			if(y2 < y1)
			  item.linePath = `${x1} ${y1 - cy} ${x2} ${y2 - cy}`;
			else
			  item.linePath = `${x1} ${y1 + cy} ${x2} ${y2 + cy}`;
		}
	}
});
Space.model('container', function(self, root){
	self.cableScope = root('cables');
	self.nodeScope = root('nodes');

	function onlyNegative(old, now){
		if(now > 0) return 0;
	}

	self.pos = {x:0, y:0,
		// Because origin is top left, viewport height and width are increased on bottom right
		// Force to zero if there are no more space to be panned on left side
		on$x: onlyNegative, on$y: onlyNegative
	};

	self.scale = 1;
	self.size = {w:0, h:0};
	self.origSize = {w:0, h:0};
	self.offset;

	self.init = function(){
		self.resetOffset();
		self.size.w = self.offset.width;
		self.size.h = self.offset.height;
	}

	self.resetOffset = function(){
		self.$el.css({
			width:'100%',
			height:'100%'
		});

		self.offset = self.$el[0].getBoundingClientRect();
		self.origSize.w = self.offset.width;
		self.origSize.h = self.offset.height;
	}

	function moveContainer(ev){
		if(!(self.pos.x >= 0 && ev.movementX > 0)){
			self.size.w -= ev.movementX;
			self.pos.x += ev.movementX;
		}

		if(!(self.pos.y >= 0 && ev.movementY > 0)){
			self.size.h -= ev.movementY;
			self.pos.y += ev.movementY;
		}
	}

	self.moveContainer = function(ev){
		self.$el.on('pointermove', moveContainer).on('pointerup', function(){
			self.$el.off('pointermove', moveContainer);
		});
	}

	self.scaleContainer = function(ev){
		if(ev.deltaY > 0 && self.scale <= 0.2)
			return;

		if(ev.deltaY < 0 && self.scale >= 2)
			return;

		var delta = ev.deltaY/100 * 0.08;
		self.scale -= delta;

		// ToDo: fix scaling, should scale with cursor as the middle scaling position
		self.pos.x += ev.clientX * delta;
		self.pos.y += ev.clientY * delta;

		// self.pos will always negative or zero value
		// hint on the object declaration

		self.size.w = self.origSize.w / self.scale - self.pos.x;
		self.size.h = self.origSize.h / self.scale - self.pos.y;
	}
});
Space.component('drop-down', {template:"Blackprint/container/drop-down.html"}, function(self, root, $item){
	self.visible = false;

	self.options = $item;
	self.x = $item.x;
	self.y = $item.y;

	var currentDeepLevel;
	self.init = function(){
		var elem = self.$el[0].firstElementChild;

		if(self.x + elem.offsetWidth > window.innerWidth)
			self.x -= elem.offsetWidth;

		if(self.y + elem.offsetHeight > window.innerHeight)
			self.y -= elem.offsetHeight;

		self.visible = true;

		// Find nested options and add event listener on mouse hover
		var options = self.options;
		for (let i = 0; i < options.length; i++) {
			if(options[i].deep !== void 0){
				$(options.getElement(i)).on('mouseover', function(ev){
					if(currentDeepLevel !== void 0)
						self.deepRemove();

					if(options[i].hover !== void 0)
						options[i].hover.apply(options[i].context, options[i].args);

					var deep = options[i].deep;

					// Use the cache instead
					if(deep.el !== void 0){
						currentDeepLevel = deep.el;
						self.$el.append(deep.el);
						return;
					}

					// Initialize position once
					var rect = ev.target.getBoundingClientRect();
					deep.x = rect.left + rect.width;
					deep.y = rect.top - rect.height/2 + 7;

					deep.el = currentDeepLevel = new $DropDown(deep, Blackprint.space);
					self.$el.append(currentDeepLevel);
				});

				continue;
			}

			var elem = $(options.getElement(i));

			if(options[i].callback){
				elem.on('click', function(ev){
					if(options[i].unhover !== void 0)
						options[i].unhover.apply(options[i].context, options[i].args);

					options[i].callback.apply(options[i].context, options[i].args);
					root('dropdown').hide();
				});
			}

			if(options[i].hover){
				elem.on('mouseover', function(ev){
					options[i].hover.apply(options[i].context, options[i].args);
				});
			}

			if(options[i].unhover){
				elem.on('mouseout', function(ev){
					options[i].unhover.apply(options[i].context, options[i].args);
				});
			}
		}
	}

	self.deepRemove = function(){
		if(currentDeepLevel === void 0)
			return;

		currentDeepLevel.remove();
		currentDeepLevel.model.deepRemove();
	}
});
Space.model('dropdown', function(self){
	self.menus = [];
	self.onCancel = void 0;

	// options: [{title, callback}, {title, deep:[{...}]}, ...]
	self.show = function(options, x, y){
		// Remove last dropdown if haven't been closed
		if(self.menus.length !== 0)
			self.menus.splice(0);
		else
			manageBackdrop(true);

		options.x = x;
		options.y = y;
		self.menus.push(options);

		return self;
	}

	self.hide = function(){
		for (var i = 0; i < self.menus.length; i++)
			self.menus.getElement(i).model.deepRemove();

		self.menus.splice(0);
	}

	var backdropCreated = false;
	function backdropListener(ev){
		if($(ev.target).parent('sf-m')[0] === self.$el[0])
			return;

		backdropCreated = false;

		self.hide();
		$('body').off('click', backdropListener);
		self.onCancel && self.onCancel();
	}

	function manageBackdrop(isAdd){
		setTimeout(function(){
			if(isAdd){
				if(!backdropCreated){
					$('body').on('click', backdropListener);
					backdropCreated = true;
				}
			}
			else{
				$('body').off('click', backdropListener);
				backdropCreated = false;
			}
		}, 10);
	}
});
Space.model('nodes', function(self, root){
	self.list = [];

	function createNode(namespace){
		sketch.createNode(namespace, {x:menuEv.layerX, y:menuEv.layerY});
	}

	var menuEv;
	self.menu = function(ev){
		ev.preventDefault();
		menuEv = ev;

		var namespaces = Blackprint.nodes;

		var menu = [];
		var strArr = [];
		function deep(obj, target){
			for(var name in obj){
				if(obj[name].constructor === Function){
					target.push({
						title:name,
						args:[strArr.length !== 0 ? strArr.join('/')+'/'+name : name],
						callback:createNode
					});
					continue;
				}

				var newMenu = [];
				target.push({title:name, deep:newMenu});

				strArr.push(name);
				deep(obj[name], newMenu);
				strArr.pop();
			}
		}

		deep(namespaces, menu);
		root('dropdown').show(menu, ev.clientX, ev.clientY);
	}
});
Space.component('default-node', {
	extend: Blackprint.Node,
	template:'Blackprint/nodes/default.html'
}, function(self, root){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */
});
return Blackprint;
})));
// End of compiled file
//# sourceMappingURL=blackprint.min.js.map
