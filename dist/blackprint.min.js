/* Blackprint 
 MIT Licensed */
class Blackprint{
	constructor(){
		this.index = Blackprint.index++;
		this.scope = Blackprint.space.getScope(this.index);
	}

	cloneContainer(){
		return Blackprint.space.getHTML(Blackprint.index);
	}

	registerHandler(namespace, func){
		_.set(Blackprint.nodes, namespace.split('/'), func);
	}

	registerNode(nodeType, func){
		if(/[^\w\-]/.test(nodeType) !== false)
			return console.error("nodeType can only contain character a-zA-Z0-9 and dashes");

		Blackprint.space.component(nodeType+'-node', function(self, root){
			root('nodes').extendNode(self, root);
			func(self, root);
		});
	}

	importJSON(json){
		if(json.constructor === String)
			json = JSON.parse(json);

		var version = json.version;
		delete json.version;

		var inserted = [];

		// Prepare all nodes depend on the namespace
		// before we create cables for them
		var namespace = Object.keys(json);
		for (var i = 0; i < namespace.length; i++) {
			var nodes = json[namespace[i]];

			// Every nodes that using this namespace name
			for (var a = 0; a < nodes.length; a++)
				inserted[nodes[a].id] = this.createNode(namespace[i], {
					x:nodes[a].x,
					y:nodes[a].y
				});
		}

		// Get cable model
		var cables = Blackprint.space.scope('cables');

		// RepeatedElement can from inputs, outputs, properties
		function findPortByName(RE, name){
			if(RE.getElement === void 0)
				console.error("It seems the JSON was imported when sketch view haven't been loaded");

			for (var i = 0; i < RE.length; i++) {
				if(RE[i].name === name)
					return {
						port:RE[i],
						rect:RE.getElement(i).querySelector('.port').getBoundingClientRect()
					};
			}

			return;
		}

		// Create cable only from outputs and properties
		for (var i = 0; i < namespace.length; i++) {
			var nodes = json[namespace[i]];

			// Every nodes that using this namespace name
			for (var a = 0; a < nodes.length; a++){
				var currentNode = inserted[nodes[a].id];

				// If have outputs connection
				if(nodes[a].outputs !== void 0){
					var out = nodes[a].outputs;
					var names = Object.keys(out);

					// Every outputs port that have connection
					for (var z = 0; z < names.length; z++) {
						var foundA = findPortByName(currentNode.outputs, names[z]);
						if(foundA === void 0){
							console.error("Port not found for", currentNode, "with name:", names[z]);
							continue;
						}

						var port = out[names[z]];

						// Current outputs's available targets
						for (var k = 0; k < port.length; k++) {
							var target = port[k];
							var targetNode = inserted[target.id];

							// Outputs can only meet input port
							var foundB = findPortByName(targetNode.inputs, target.name);
							if(foundB === void 0){
								console.error("Port not found for", targetNode, "with name:", names[z]);
								continue;
							}

							// Create cable from NodeA
							cables.currentCable = currentNode.createCable(foundA.rect, foundA.port);

							// Positioning the cable head2 into target port position from NodeB
							var center = foundB.rect.width/2;
							cables.currentCable.head2 = [foundB.rect.x+center, foundB.rect.y+center];

							// Connect cable to NodeB
							targetNode.cableConnect(foundB.port);
						}
					}
				}
			}
		}
	}

	// @return node scope
	createNode(namespace, options){
		var func = _.get(Blackprint.nodes, namespace.split('/'));
		if(func === void 0)
			return console.error('Node for', namespace, "was not found") && void 0;

		// Processing scope is different with node scope
		var handle = {}, node = {type:'default', title:'No Title', description:''};
		func(handle, node);

		// Type extract for port data type
		// Create reactiveness of handle and node's ports
		function extract(which){
			var link = node[which] = [];
			var local = handle[which];
			if(local === void 0)
				return;

			var temp = Object.keys(local);
			for (let i = 0; i < temp.length; i++) {
				var prepare = {
					get:function(){
						if(link[i].value === void 0){
							if(link[i].root === void 0)
								return link[i].default;

							// Run from root node and stop when reach this node
							link[i].root(link[i]);
						}

						return link[i].value;
					}
				};

				// Can only obtain data when accessing input port
				if(which !== 'inputs'){
					prepare.set = function(val){
						link[i].value = val;
						return link[i].value || link[i].default;
					}
				}

				// Determine type and add default value for each type
				var type, def;
				if(typeof local[temp[i]] === 'function'){
					type = local[temp[i]];

					// Give default value for each data type
					if(type === Number)
						def = 0;
					else if(type === Boolean)
						def = false;
					else if(type === String)
						def = '';
					else if(type === Array)
						def = [];
					else if(type === Object)
						def = {};
					else if(type.constructor === Function)
						def = void 0;
					else return console.error(type, "was unrecognized as an port data type");
				}
				else if(local[temp[i]] === null)
					type = {name:'Any'};
				else type = local[temp[i]].constructor;

				// Set for the linked node
				link.push({name:temp[i], type:type, default:def, cables:[]});

				// Set on the local scope
				Object.defineProperty(local, temp[i], prepare);
			}
		}

		var portType = ['inputs', 'outputs', 'properties'];
		for (var i = 0; i < portType.length; i++)
			extract(portType[i]);

		if(options !== void 0)
			Object.assign(node, options);

		// Node is become the component scope
		this.scope('nodes').list.push(node);
		return node;
	}
}

Blackprint.nodes = {};
Blackprint.index = 0;

// Start private scope for Blackprint Module
;(function(){

// Let's define `Space` that handle model and component as global variable on our private scope
var Space = Blackprint.space = sf.space('blackprint', {
	templatePath:'Blackprint/page.html'
});
;(function(){
var root = Blackprint.space.scope;

class Node{
	// DragMove event handler
	moveNode(e){
		this.x += e.movementX;
		this.y += e.movementY;

		this.moveCables(e, this.inputs);
		this.moveCables(e, this.outputs);
		this.moveCables(e, this.properties);
	}

	moveCables(e, which){
		// Move the connected cables
		for (var i = 0; i < which.length; i++) {
			var cables = which[i].cables;
			if(cables.length === 0)
				continue;

			for (var a = 0; a < cables.length; a++) {
				var cable;
				if(cables[a].owner[0] === this)
					cable = cables[a].head1;
				else
					cable = cables[a].head2;

				cable[0] += e.movementX;
				cable[1] += e.movementY;
			}
		}
	}

	// Determine port source
	getPortSource(item){
		if(this.outputs.indexOf(item) !== -1)
			return 'outputs';
		else if(this.properties.indexOf(item) !== -1)
			return 'properties';
		return 'inputs';
	}

	// PointerDown event handler
	createCable(e, item){
		var source = this.getPortSource(item);
		var isAuto = e.constructor === DOMRect;

		// Get size and position of the port
		var rect = isAuto ? e : e.target.getBoundingClientRect();
		var center = rect.width/2;

		// Create cable and save the reference
		var cable = root('cables').createCable({
			x:rect.x + center,
			y:rect.y + center,
			type:item.type === null ? 'Any' : item.type.name,
			source:source
		});

		// Connect this cable into port's cable list
		item.cables.push(cable);

		// Put port reference to the cable
		cable.owner = [this, item];

		// Stop here if this function wasn't triggered by user
		if(isAuto)
			return cable;

		// Default head index is "2" when creating new cable 
		root('cables').cableHeadClicked(cable, 2);
	}

	removeCable(cable){
		var list = root('cables').list;

		// Remove from cable owner
		if(cable.owner){
			var i = cable.owner[1].cables.indexOf(cable);
			if(i !== -1)
				cable.owner[1].cables.splice(i, 1);
		}

		// Remove from connected target
		if(cable.target){
			var i = cable.target[1].cables.indexOf(cable);
			if(i !== -1)
				cable.target[1].cables.splice(i, 1);
		}

		// Remove from cable list
		list.splice(list.indexOf(cable), 1);
		console.log('A cable was removed', cable);
	}

	// PointerUp event handler
	cableConnect(port){
		// Get currect cable and the port source name
		var cable = root('cables').currentCable;
		var source = this.getPortSource(port);

		// Remove cable if ...
		if(cable.owner[0] === this // It's referencing to same node
			|| cable.source === 'outputs' && source !== 'inputs' // Output source not connected to input
			|| cable.source === 'inputs' && source !== 'outputs'  // Input source not connected to output
			|| cable.source === 'properties' && source !== 'properties'  // Property source not connected to property
		){
			console.log(cable.owner[0], this);
			this.removeCable(cable);
			return;
		}

		// Connect this cable into port's cable list
		port.cables.push(cable);

		// Put port reference to the cable
		cable.target = [this, port];
		console.log('A cable was connected', port);
	}

	// PointerOver event handler
	portHovered(event, item){
		// For magnet sensation when the cable reach the port
		root('cables').hoverPort = {
			elem:event.target,
			rect:event.target.getBoundingClientRect(),
			item:item
		};
	}

	// PointerOut event handler
	portUnhovered(){
		root('cables').hoverPort = false;
	}
}

Blackprint.Node = Node;
})();
Space.model('cables', function(self){
	/*{
		head1:[x,y], -- Number
		head2:[x,y], -- Number
		type:'String',
		curve:self.curve[..],
		valid:true,

		nodeA:Object,
		nodeB:Object,
	}*/
	self.list = [];

	// Fixing viewport position
	self.space = [0,0];
	self.init = function(){
		setTimeout(function(){
			// Get sf-space element
			var rect = self.$el[0].parentNode.getBoundingClientRect();
			self.space = [rect.x, rect.y];
		}, 500);
	}

	// Flag if cursor was hovering a node port
	self.hoverPort = false; // {elem:, item:}

	// This will run everytime the cable was moving
	self.recalculatePath = function(item){
		var x1 = item.head1[0], y1 = item.head1[1];
		var x2 = item.head2[0], y2 = item.head2[1];

		// Written without formula, just logic...
		if(item.source !== 'properties'){
			var cx = (x2-x1)/2;
			if(cx > -50 && cx < 0)
				cx = -50;
			else if(cx < 50 && cx >= 0)
				cx = 50;

			if(item.source === 'inputs'){
				if(x2 < x1)
				  item.linePath = `${x1 + cx} ${y1} ${x2 - cx} ${y2}`;
				else
				  item.linePath = `${x1 - cx} ${y1} ${x2 + cx} ${y2}`;
			}
			else if(item.source === 'outputs'){
				if(x2 < x1)
				  item.linePath = `${x1 - cx} ${y1} ${x2 + cx} ${y2}`;
				else
				  item.linePath = `${x1 + cx} ${y1} ${x2 - cx} ${y2}`;
			}
		}
		else{
			var cy = (y2-y1)/2;
			if(cy > -50 && cy < 0)
				cy = -50;
			else if(cy < 50 && cy >= 0)
				cy = 50;

			if(y2 < y1)
			  item.linePath = `${x1} ${y1 - cy} ${x2} ${y2 - cy}`;
			else
			  item.linePath = `${x1} ${y1 + cy} ${x2} ${y2 + cy}`;
		}
	}

	// Move clicked cable
	self.currentCable = void 0;
	self.cableHeadClicked = function(item){
		function moveCableHead(event){
			var xy;

			// Let's make a magnet sensation (fixed position when hovering node port)
			if(self.hoverPort !== false){
				var center = self.hoverPort.rect.width/2;
				xy = [self.hoverPort.rect.x+center, self.hoverPort.rect.y+center];
			}

			// Follow pointer
			else xy = [event.clientX, event.clientY];

			item.head2 = xy;
		}

		var elem = self.list.getElement(item);

		// Let the pointer pass thru the current svg group
		if(elem !== void 0){
			elem = $(elem);
			elem.css('pointer-events', 'none');
		}

		// Save current cable for referencing when cable connected into node's port
		self.currentCable = item;
		$('vw-sketch').on('pointermove', moveCableHead).once('pointerup', function(event){
			$('vw-sketch').off('pointermove', moveCableHead);

			// Add delay because it may be used for connecting port
			setTimeout(function(){
				self.currentCable = void 0;
			}, 100);

			if(elem !== void 0)
				elem.css('pointer-events', '');
		});
	}

	self.createCable = function(obj){
		return self.list[self.list.push({
			head1:[obj.x, obj.y],
			head2:[obj.x, obj.y],
			type:obj.type,
			source:obj.source,
			valid:true,
			linePath:'0 0 0 0',

			// Cable connection
			owner:void 0, // head1
			target:void 0 // head2
		}) - 1];
	}
});
Space.model('nodes', function(self, root){
	self.list = [];
});
;(function(){
var root = Blackprint.space.scope;

class Function extends Blackprint.Node{
	static init(){
	}

	run(){
		console.error("The trigger handler doesn't have `run` method");
	}
}

Blackprint.Function = Function;
})();
;(function(){
var root = Blackprint.space.scope;

class Input extends Blackprint.Node{
	static init(){
	}

	run(){
		console.error("The trigger handler doesn't have `run` method");
	}
}

Blackprint.Input = Input;
})();
;(function(){
var root = Blackprint.space.scope;

class Trigger extends Blackprint.Node{
	static init(){
		root('nodes').trigger.push(this);
	}

	run(){
		console.error("The trigger handler doesn't have `run` method");
	}
}

Blackprint.Trigger = Trigger;
})();
Space.component('button-node', {
	extend: Blackprint.Trigger,
	template: 'Blackprint/nodes/button.html'
}, function(self, root){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	self.run = function(){
		console.log('yosh');
	}
});
Space.component('default-node', {
	extend: Blackprint.Node,
	template:'Blackprint/nodes/default.html'
}, function(self, root){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */
});
Space.component('input-node', {
	extend: Blackprint.Input,
	template: 'Blackprint/nodes/input.html'
}, function(self, root){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	self.log = '';
});
Space.component('logger-node', {
	extend: Blackprint.Function,
	template: 'Blackprint/nodes/logger.html'
}, function(self, root){
	// Property of this scope
	/* self == {
		x: 0,
		y: 0,
		inputs: [],
		outputs: [],
		properties: [],
	} */

	self.log = '...';
});
})();
//# sourceMappingURL=blackprint.min.1583848249073.js.map
